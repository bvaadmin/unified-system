// Oracle Database Adapter
// Handles connection pooling and transaction management for Oracle Autonomous Database

import oracledb from 'oracledb';
import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';

// Load environment variables
dotenv.config();

// Configure Oracle client: use arrays; some callers depend on array rows
oracledb.outFormat = oracledb.OUT_FORMAT_ARRAY;

let pool = null;

// Oracle connection configuration for Thin mode (no client installation required)
const oracleConfig = {
  user: process.env.ORACLE_USER || 'ADMIN',
  password: process.env.ORACLE_PASSWORD,
  // Use the full TNS entry from the environment variable directly
  connectString: process.env.ORACLE_TNSNAMES_ORA,
  poolMin: 2,
  poolMax: 10,
  poolIncrement: 2,
  poolTimeout: 300 // seconds
};

/**
 * Initialize Oracle connection pool (Thin mode - no client libraries required)
 */
export async function initializePool() {
  try {
    if (!pool) {
      console.log('Creating Oracle connection pool (Thin mode)...');
      
      const poolConfig = {
        user: oracleConfig.user,
        password: oracleConfig.password,
        connectString: oracleConfig.connectString
      };

      const safeLog = { ...poolConfig };
      if ('password' in safeLog) safeLog.password = '[HIDDEN]';
      console.log('Pool configuration:', safeLog);

      pool = await oracledb.createPool(poolConfig);
      console.log('Oracle connection pool created successfully');
    }
    return pool;
  } catch (error) {
    console.error('Error creating Oracle pool:', error);
    throw error;
  }
}

/**
 * Get a connection from the pool
 */
export async function getConnection() {
  try {
    if (!pool) {
      await initializePool();
    }
    const connection = await pool.getConnection();
    return connection;
  } catch (error) {
    console.error('Error getting Oracle connection:', error);
    throw error;
  }
}

/**
 * Close the connection pool
 */
export async function closePool() {
  try {
    if (pool) {
      await pool.close(0); // Force close
      pool = null;
      console.log('Oracle connection pool closed');
    }
  } catch (error) {
    console.error('Error closing Oracle pool:', error);
    throw error;
  }
}

/**
 * Execute a query with automatic connection management
 */
export async function executeQuery(sql, binds = []) {
  let connection;
  try {
    connection = await getConnection();
    const result = await connection.execute(sql, binds);
    return result;
  } catch (error) {
    console.error('Error executing Oracle query:', error);
    throw error;
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing Oracle connection:', err);
      }
    }
  }
}

/**
 * Execute a function with an Oracle connection
 */
export async function withOracleConnection(connectionFn) {
  let connection;
  try {
    connection = await getConnection();
    const result = await connectionFn(connection);
    return result;
  } catch (error) {
    console.error('Error in Oracle connection function:', error);
    throw error;
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing Oracle connection:', err);
      }
    }
  }
}

/**
 * Execute a transaction with automatic rollback on error
 */
export async function withOracleTransaction(transactionFn) {
  let connection;
  try {
    connection = await getConnection();
    
    // Execute the transaction function
    const result = await transactionFn(connection);
    
    // Commit if successful
    await connection.commit();
    return result;
  } catch (error) {
    // Rollback on error
    if (connection) {
      try {
        await connection.rollback();
      } catch (rollbackError) {
        console.error('Error during rollback:', rollbackError);
      }
    }
    throw error;
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing connection after transaction:', err);
      }
    }
  }
}

/**
 * Convert PostgreSQL parameter style ($1, $2) to Oracle style (:1, :2)
 */
export function convertParameterStyle(sql) {
  let paramCount = 0;
  return sql.replace(/\$(\d+)/g, (match, num) => {
    paramCount = Math.max(paramCount, parseInt(num));
    return `:${num}`;
  });
}

/**
 * Convert PostgreSQL-specific SQL to Oracle-compatible SQL
 */
export function convertSQLToOracle(sql) {
  let oracleSQL = convertParameterStyle(sql);
  
  // Common PostgreSQL to Oracle conversions
  oracleSQL = oracleSQL
    .replace(/SERIAL/gi, 'NUMBER GENERATED BY DEFAULT AS IDENTITY')
    .replace(/BOOLEAN/gi, 'NUMBER(1)')
    .replace(/TEXT/gi, 'CLOB')
    .replace(/TIMESTAMP WITH TIME ZONE/gi, 'TIMESTAMP WITH TIME ZONE')
    .replace(/NOW\(\)/gi, 'CURRENT_TIMESTAMP')
    .replace(/LIMIT\s+(\d+)/gi, 'FETCH FIRST $1 ROWS ONLY')
    .replace(/ILIKE/gi, 'LIKE')
    .replace(/~~\*/gi, 'LIKE')
    .replace(/!~~\*/gi, 'NOT LIKE');
  
  return oracleSQL;
}

/**
 * Helper function to create Oracle BIND_OUT parameters
 */
export function createBindOut(type = oracledb.STRING) {
  return {
    dir: oracledb.BIND_OUT,
    type: type
  };
}

/**
 * Health check for Oracle connection
 */
export async function healthCheck() {
  try {
    const result = await executeQuery('SELECT 1 as health FROM dual');
    return result.rows[0][0] === 1;
  } catch (error) {
    console.error('Oracle health check failed:', error);
    return false;
  }
}

// Export oracledb for direct access to constants
export { oracledb };

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('Received SIGINT, closing Oracle pool...');
  await closePool();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('Received SIGTERM, closing Oracle pool...');
  await closePool();
  process.exit(0);
});
