// Oracle Database Adapter
// Handles connection pooling and transaction management for Oracle Autonomous Database

import oracledb from 'oracledb';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

// Enable Thin mode
oracledb.thin = true;

let pool = null;

export async function initializePool() {
  console.log('--- ENTERING initializePool ---');
  try {
    if (pool) {
      console.log('Pool already exists.');
      return pool;
    }

    console.log('Creating Oracle connection pool (Thin mode)...');
    console.log('ORACLE_USER:', process.env.ORACLE_USER);
    console.log('ORACLE_PASSWORD:', process.env.ORACLE_PASSWORD ? '[SET]' : '[NOT SET]');
    console.log('ORACLE_CONNECT_STRING:', process.env.ORACLE_CONNECT_STRING);

    const poolConfig = {
      user: process.env.ORACLE_USER,
      password: process.env.ORACLE_PASSWORD,
      connectString: process.env.ORACLE_CONNECT_STRING
    };

    console.log('Pool configuration (before createPool):', {
      user: poolConfig.user,
      connectString: poolConfig.connectString,
      password: poolConfig.password ? '[SET]' : '[NOT SET]'
    });

    pool = await oracledb.createPool(poolConfig);

    console.log('Oracle connection pool created successfully.');
    return pool;
  } catch (error) {
    console.error('--- Error in initializePool ---');
    console.error(error);
    throw error;
  } finally {
    console.log('--- EXITING initializePool ---');
  }
}

export async function getConnection() {
  console.log('--- ENTERING getConnection ---');
  try {
    if (!pool) {
      console.log('Pool does not exist, initializing...');
      await initializePool();
    }
    const connection = await pool.getConnection();
    console.log('Successfully got a connection from the pool.');
    return connection;
  } catch (error) {
    console.error('--- Error in getConnection ---');
    console.error(error);
    throw error;
  } finally {
    console.log('--- EXITING getConnection ---');
  }
}

/**
 * Close the connection pool
 */
export async function closePool() {
  try {
    if (pool) {
      await pool.close(0); // Force close
      pool = null;
      console.log('Oracle connection pool closed');
    }
  } catch (error) {
    console.error('Error closing Oracle pool:', error);
    throw error;
  }
}

/**
 * Execute a query with automatic connection management
 */
export async function executeQuery(sql, binds = []) {
  let connection;
  try {
    connection = await getConnection();
    const result = await connection.execute(sql, binds);
    return result;
  } catch (error) {
    console.error('Error executing Oracle query:', error);
    throw error;
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing Oracle connection:', err);
      }
    }
  }
}

/**
 * Execute a function with an Oracle connection
 */
export async function withOracleConnection(connectionFn) {
  let connection;
  try {
    connection = await getConnection();
    const result = await connectionFn(connection);
    return result;
  } catch (error) {
    console.error('Error in Oracle connection function:', error);
    throw error;
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing Oracle connection:', err);
      }
    }
  }
}

/**
 * Execute a transaction with automatic rollback on error
 */
export async function withOracleTransaction(transactionFn) {
  let connection;
  try {
    connection = await getConnection();
    
    // Execute the transaction function
    const result = await transactionFn(connection);
    
    // Commit if successful
    await connection.commit();
    return result;
  } catch (error) {
    // Rollback on error
    if (connection) {
      try {
        await connection.rollback();
      } catch (rollbackError) {
        console.error('Error during rollback:', rollbackError);
      }
    }
    throw error;
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing connection after transaction:', err);
      }
    }
  }
}

/**
 * Convert PostgreSQL parameter style ($1, $2) to Oracle style (:1, :2)
 */
export function convertParameterStyle(sql) {
  let paramCount = 0;
  return sql.replace(/\$(\d+)/g, (match, num) => {
    paramCount = Math.max(paramCount, parseInt(num));
    return `:${num}`;
  });
}

/**
 * Convert PostgreSQL-specific SQL to Oracle-compatible SQL
 */
export function convertSQLToOracle(sql) {
  let oracleSQL = convertParameterStyle(sql);
  
  // Common PostgreSQL to Oracle conversions
  oracleSQL = oracleSQL
    .replace(/SERIAL/gi, 'NUMBER GENERATED BY DEFAULT AS IDENTITY')
    .replace(/BOOLEAN/gi, 'NUMBER(1)')
    .replace(/TEXT/gi, 'CLOB')
    .replace(/TIMESTAMP WITH TIME ZONE/gi, 'TIMESTAMP WITH TIME ZONE')
    .replace(/NOW\(\)/gi, 'CURRENT_TIMESTAMP')
    .replace(/LIMIT\s+(\d+)/gi, 'FETCH FIRST $1 ROWS ONLY')
    .replace(/ILIKE/gi, 'LIKE')
    .replace(/~~\*/gi, 'LIKE')
    .replace(/!~~\*/gi, 'NOT LIKE');
  
  return oracleSQL;
}

/**
 * Helper function to create Oracle BIND_OUT parameters
 */
export function createBindOut(type = oracledb.STRING) {
  return {
    dir: oracledb.BIND_OUT,
    type: type
  };
}

/**
 * Health check for Oracle connection
 */
export async function healthCheck() {
  try {
    const result = await executeQuery('SELECT 1 as health FROM dual');
    return result.rows[0][0] === 1;
  } catch (error) {
    console.error('Oracle health check failed:', error);
    return false;
  }
}

// Export oracledb for direct access to constants
export { oracledb };

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('Received SIGINT, closing Oracle pool...');
  await closePool();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('Received SIGTERM, closing Oracle pool...');
  await closePool();
  process.exit(0);
});
